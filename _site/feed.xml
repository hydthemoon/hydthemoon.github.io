<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-08-11T21:51:46+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">달숨기자 블로그</title><subtitle>hi there</subtitle><author><name>Jaehyun Kim</name></author><entry><title type="html">[JAVA] 접근 제한자</title><link href="http://localhost:4000/java/Java-access-modifier/" rel="alternate" type="text/html" title="[JAVA] 접근 제한자" /><published>2022-08-11T00:00:00+09:00</published><updated>2022-08-11T00:00:00+09:00</updated><id>http://localhost:4000/java/%5BJava%5D-access-modifier</id><content type="html" xml:base="http://localhost:4000/java/Java-access-modifier/"><![CDATA[<p>저는 처음 자바 코드를 봤을때(사실 바로 지난주), 길다란 클래스 수식어들 때문인지 머리가 어지러워지고 말았습니다. 이번에는 그 주범인 접근제한자 - class modifier에 대해 잊지 않게 간략히 정리해두었다.</p>

<h2 id="포함-관계">포함 관계</h2>

<p>선언된 대상을 접근할 수 있는 클래스를 기준으로 포함관계를 나타내면 아래와 같습니다.</p>

<p><img width="400" alt="classmodi" src="https://user-images.githubusercontent.com/40457043/184095515-901d6f08-b94b-4cfe-8f4d-082f14834203.png" /></p>

<p>(default란 아무것도 안적은 상황을 의미한다.)</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"><center>modifier</center></th>
      <th style="text-align: center"><center>접근 가능성</center></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>public</strong></td>
      <td style="text-align: center"><center>모든 패키지에서 가능</center></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>protected</strong></td>
      <td style="text-align: center"><center>같은 패키지 + 선언된 클래스의 child 클래스</center></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>default</strong></td>
      <td style="text-align: center"><center>같은 패키지의 클래스들</center></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>private</strong></td>
      <td style="text-align: center"><center>내부만 가능</center></td>
    </tr>
  </tbody>
</table>

<p>위의 규칙들은 클래스 뿐만 아니라 변수나 메서드 등에도 같이 적용된다.</p>

<p>접근제어자의 적절한 활용을 통해 실수를 방지하고 위험회피가 가능해진다.</p>

<h2 id="예시">예시</h2>

<p>…</p>

<h2 id="참고">참고</h2>

<p><a href="https://www.javatpoint.com/access-modifiers">javatpoint</a></p>

<h2 id="여담">여담</h2>

<p>아직 package 관리나 maven이나 graddle이냐 이런것들은 잘 모르겠는데 배울게 많다 ,,</p>]]></content><author><name>Jaehyun Kim</name></author><category term="JAVA" /><category term="접근 제한자" /><summary type="html"><![CDATA[저는 처음 자바 코드를 봤을때(사실 바로 지난주), 길다란 클래스 수식어들 때문인지 머리가 어지러워지고 말았습니다. 이번에는 그 주범인 접근제한자 - class modifier에 대해 잊지 않게 간략히 정리해두었다.]]></summary></entry><entry><title type="html">알고리즘에서의 고속 푸리에 변환</title><link href="http://localhost:4000/algo/Algo-FFT/" rel="alternate" type="text/html" title="알고리즘에서의 고속 푸리에 변환" /><published>2022-07-29T00:00:00+09:00</published><updated>2022-07-29T00:00:00+09:00</updated><id>http://localhost:4000/algo/%5BAlgo%5D-FFT</id><content type="html" xml:base="http://localhost:4000/algo/Algo-FFT/"><![CDATA[<h2 id="fourier-series--transfrom-review">Fourier Series &amp; Transfrom Review</h2>

<p>보통 이공계 학부생이라면 2학년 즈음에 신호및시스템 수업 혹은 복소함수론 수업에서 푸리에 급수와 변환에 대해 배웠을 것이다. 주인장의 경우 2학년 2학기 때 두 과목을 같이 들었는데, 수학과에서 열린 복소함수론 수업 초반에 Fourier Analysis하면서 좀 보고, 신호 수업에서 계산을 미친듯이 많이 했던 기억이 난다. 어쨋든, Fourier Transform을 간략하게 정리해보자.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"><center>Time Property</center></th>
      <th style="text-align: center"><center>Periodic</center></th>
      <th style="text-align: right"><center>Nonperiodic</center></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Continuous</strong></td>
      <td style="text-align: center"><center>Fourier Series (FS)</center></td>
      <td style="text-align: right"><center>Fourier Transform (FT)</center></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Discrete</strong></td>
      <td style="text-align: center"><center>Discrete-Time Fourier Series (DTFS)</center></td>
      <td style="text-align: right"><center> Discrete-Time Fourier Transform (DTFT)</center></td>
    </tr>
  </tbody>
</table>

<h3 id="fourier-series">Fourier Series</h3>

\[x(t) = \sum_{k=-\infty}^{\infty} X[k] e^{jkw_o t}\]

<h3 id="discrete-time-fourier-series">Discrete-Time Fourier Series</h3>

\[x[n] = \sum_{k=&lt;N&gt;}^{} X[k] e^{jk\Omega_o n}\]

<h3 id="fourier-transform">Fourier Transform</h3>

\[x(t) = \frac{1}{2\pi}\int_{-\infty}^{\infty} X(jw)e^{jwt} \,dw\]

<h3 id="discrete-time-fourier-transform">Discrete-Time Fourier Transform</h3>

\[x[n] = \frac{1}{2\pi}\int_{2\pi}^{} X(e^{j\Omega})e^{j\Omega n} \,d\Omega\]

<p>나와 같은 테크를 탄 공대생이라면 기존에 배운 푸리에 어쩌고의 개념은 위 공식과 함께 time domain에 있는 신호를 freq domain으로 convert해주는 것이라고 알고 있을 것이다. 그 배경에는 laplace 변환에서 시작해서 LTI system 등등 여러 개념들이 등장하지만 일단 이 포스트에서는 그부분까지 다루지는 않겠다.</p>

<p>그런데, 사실 큰 수의 곱셈을 할 때도 쓰인다는 것을 알고 있을까? 일단 나는 몰랐다! 이제부터 이쪽에 초점을 맞춰서 살펴보자.</p>

<h2 id="다항식-곱셈에서의-적용">다항식 곱셈에서의 적용</h2>

<h3 id="접근-아이디어">접근 아이디어</h3>

<p>아래 두 polynomial을 곱하는데에는 Time Complexity가 어떻게 될까?</p>

\[\begin{align} A(x) &amp;= a_0 + a_1x + \ldots + a_nx^n \\ B(x) &amp;= b_0 + b_1x + \ldots + b_m x^m\end{align}\]

<p>물론 ${O(nm)}$일 것이다. 우리는 두가지 방법으로 곱해진 결과 polynomial ${C(x)}$을 구할 수 있는데,</p>

<ol>
  <li>직접 곱한다.</li>
  <li>각 polynomial에서 ${n+m}$개 point ${x_i}$를 뽑아서 각 ${A(x_i)B(x_i)}$를 통해 ${c_i}$들을 알아낸다.</li>
</ol>

<p>보통 첫번째 방법으로 구현을 할텐데, 두번째 방법은 뭔가 달라보인다. 먼저, 각 point를 얻어내는데 ${O(n+m)}$이 걸릴테고, 다음으로 곱하는데 ${O(1)}$이 필요하다. 하지만, ${n + m}$ points에 대해 반복해야하므로 결국 complextiy는 제곱을 유지한다. 그렇다면, point를 구하는 complexity를 줄이면 어떻게 해볼 수 있지 않을까? 이를테면 우함수의 대칭성과 같은 성질을 통해서 말이다. 아래 예시를 살펴보자.</p>

\[\begin{align} A(x) &amp;= x^8 + x^2 + 1 \\ B(x) &amp;= x^4 + 1 \end{align}\]

<p>이렇게 주어졌다면, 둘다 우함수인게 눈에 띈다. 우함수라는건 point를 한개 얻으면 반대쪽 point도 바로 얻을 수 있다는 의미이다. 예를 들자면,</p>

\[\begin{align}A(x) &amp;: (1, 3), (2, 261) \\ B(x) &amp;: (1, 2), (2, 17)\end{align}\]

<p>이렇게 각 2 points를 얻었다면, 연산 없이 아래의 정보를 얻을 수 있다.</p>

\[\begin{align}A(x) &amp;: (-1, 3), (-2, 261) \\ B(x) &amp;: (-1, 2), (-2, 17)\end{align}\]

<p>즉, ${x}$와 ${-x}$가 하나의 쌍으로 얻어지는 것이다.</p>

<p>ok, point를 구하는데 필요한 연산량을 절반으로 줄였다. 만약 기함수였다면? 물론 부호만 반대로 바꿔주면 된다. 만약 둘다 아니라면? 우함수와 기함수로 나눠줘서 수행하면 된다. 예를 들자면 아래와 같이 진행할 수 있다.</p>

\[\begin{align} A(x) &amp;= x^3 + x^2 + 1\end{align}\]

<p>위와 같이 주어졌다면,</p>

\[\begin{align} A_1(x) &amp;= x^3 \\ A_2(x) &amp;= x^2 + 1 \end{align}\]

<p>로 나누어서 point들을 구하고 ${A(x) = A_1(x) + A_2(x)}$ 해주면 같은 방법으로 구할 수 있다.</p>

<p>하지만, 아쉽게도 Time Complexity의 Big O 단위는 변함이 없다. 여기서 신호및시스템을 수강한 눈치가 빠른학생은 어떻게 더 진전시킬 수 있을지 감이 잡힐 것이다. 바로 이 과정을 FFT를 하듯 recursive하게 해주는 방법이다.</p>

<p>지금까지 우(기)함수의 대칭성을 이용할 수 있었던 이유는, ${x^2 = (-x)^2}$이기 때문이다. 그래서 2개씩 매칭이 됐는데, 4개씩 하려면? ${i}$를 붙여주면 해결할 수 있다. ${x^2 = (ix)^2 = (-x)^2 = (-ix)^2}$이기 때문이다. 이렇게 되면, 4개의 point가 하나의 set가 된다. 8씩 하려면? 간단히 ${i (=e^{\pi / 2})}$대신 ${\frac{1 + i}{\sqrt{2}} = e^{\pi / 4}}$를 써주면 된다. 계속해서 진행한다면, 최고차항 이상의 가장 작은 2의 거듭제곱 수만큼의 대칭성을 이용할 수 있고, 결과적으로 point를 구하는데 드는 연산량이 ${n}$에서 ${\log_2 n}$으로 줄어드며, 전체 복잡도는 ${n\log n}$으로 떨어지게 된다.</p>

<ul>
  <li>이걸 처음 배웠을 때 이렇게 컴퓨팅적 사고를 하는 과정이 꽤나 신기했다. 결국은 polynomial에서 여러 point들의 좌표를 얻어낼 때 빠른 속도로 얻어내는 알고리즘인 것인데, FFT를 배우기전에는 그냥 괄호를 적절히 사용해서 하지 않을까 생각했었다. 예를 들자면 
 \(\begin{align}
 A(x) &amp;= x^4 + 2x^3 + 4x^2 + 2x + 1 \\ &amp;= (((x + 2)x + 4)x + 2)x + 1 \end{align}\)
 이런 식으로 얻어내지 않을까하는 아마추어 같은ㅎㅎ 생각을 했는데, 훨씬 멋진 방법으로 제대로 해결하는 것을 보며 감명 받았다.</li>
</ul>

<p>어쨋든 idea를 알았으니 식을 세우고 구현을 해보자.</p>

<p>우선 최고차항이 2의 거듭제곱-1 꼴이라고 두자. 아닐 경우 0으로 채워주면 된다.</p>

<p>우함수로 했을 때를 생각해보면 아래와 같이 식을 세울 수 있다. (${A_e}$는 우함수 term, ${A_o}$는 기함수 term을 의미함)</p>

\[\begin{align} A(x) &amp;= A_e(x^2) + xA_o(x^2) \\ A(-x) &amp;= A_e(x^2) - xA_o(x^2)\end{align}\]

<ul>
  <li>e.g. ${x^4 + 2x^3 + 4x^2 + 2x + 1 = ((x^2)^2 + 4(x^2) + 1) + x(2x^2 + 2)}$</li>
</ul>

<p>이제 이 식을 적절한 ${w = e^{2\pi i / n}}$로 확장시켜주면 아래와 같다.</p>

\[\begin{align} A(w^i) &amp;= A_e(w^{2i}) + w^iA_o(w^{2i}) \\ A(-w^i) = A(w^{i+n/2}) &amp;= A_e(w^{2i}) - w^iA_o(w^{2i})\end{align}\]

<h3 id="구현">구현</h3>

<p>이제, 두단계로 나눠 구현을 완성해보자.</p>

<ol>
  <li>각 polynomial에서 point를 뽑음 : FFT 함수</li>
  <li>뽑은 point배열 2개를 pointwise 곱셈을 통해 결과 point 배열을 얻는다.</li>
  <li>결과 point로부터 polynomial을 구함 : IFFT 함수</li>
</ol>

<p>일단 복소평면 연산을 자주 해야하기 때문에 <code class="language-plaintext highlighter-rouge">cmath</code>에서 가져오자.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">cmath</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">pi</span>
</code></pre></div></div>

<h4 id="fft">FFT</h4>

<p>이번 포스트에서는 비교적 이해하기 쉬운 top-down 방식으로 코드를 구현했다.</p>

<p>또한, input인 <code class="language-plaintext highlighter-rouge">a</code>변수에는 최고차항이 2의 거듭제곱-1 꼴인 polynomial의 계수가 상수항부터 차례로 담겨있다고 가정하자.</p>
<ul>
  <li>그렇지 않을 경우 적절히 0을 fill해서 처리해주자.</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">FFT</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">:</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="n">a_e</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">a_o</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="n">exp</span><span class="p">(</span><span class="mf">2j</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="n">N</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">a_e</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="n">a_o</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">a_e</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">w</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="n">a_o</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span>
</code></pre></div></div>

<h4 id="pointwise-multiplication">pointwise multiplication</h4>

<p>polynomial coeff 배열 <code class="language-plaintext highlighter-rouge">a</code>와 <code class="language-plaintext highlighter-rouge">b</code>가 주어졌다면, 아래와 같이 그냥 냅다 곱해준다.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c_fft</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">FFT</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">FFT</span><span class="p">(</span><span class="n">b</span><span class="p">))]</span>
</code></pre></div></div>

<h4 id="ifft">IFFT</h4>

<p>이제, 결과를 가지고 polynomial의 계수를 구해주면 끝난다.</p>

<p>간단히 말하면 역을 취해주면 되는 것인데, 계수에서 point를 얻을 때 사용한 방법에 역행렬을 취해서 point에서 계수를 얻는 방법을 얻어낸다고 볼 수 있다.</p>

<p>놀랍게도(사실 행렬을 보면 꽤나 그럴만함) FFT와 비슷한 형태를 가지고 있는데, FFT 코드를 조금만 손봐주면 된다.</p>

<p>자세한 증명과정은 [추가예정]</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">IFFT</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">:</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="n">a_e</span> <span class="o">=</span> <span class="n">ifft</span><span class="p">(</span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">a_o</span> <span class="o">=</span> <span class="n">ifft</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2j</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="n">N</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">a_e</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="n">a_o</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">a_e</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">w</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="n">a_o</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span>
</code></pre></div></div>

<h2 id="예제-1--이동">예제 1 : 이동</h2>

<p>FFT 근본 문제 중 하나인 <a href="https://www.acmicpc.net/problem/1067">이동</a> 문제를 해결해보자.</p>

<p>이 문제의 key idea는 간단한데, 예제 입력 1을 통해 설명하자면 다음과 같다.</p>

<p>input</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4
1 2 3 4
6 7 8 5
</code></pre></div></div>
<p>아래와 같이 바꿔준다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = [1, 2, 3, 4, 1, 2, 3, 4]
b = [5, 8, 7, 6, 0, 0, 0, 0]
</code></pre></div></div>
<p>그리고 <code class="language-plaintext highlighter-rouge">a</code>와 <code class="language-plaintext highlighter-rouge">b</code>를 계수로 하는 polynomial 곱셈을 수행하면 결과값이 어떻게 될까?</p>

<p>상수항은 a[0] * b[0], 일차항은 a[1] * b[0] + a[0] * b[1], 이차항은 a[2] * b[0] + a[1] * b[1] + a[0] * b[2] …</p>

<p>우리가 필요한 구간은 4개 곱의 합 구간이다. 두 <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>를 직접 곱해보면, 3차항은 <code class="language-plaintext highlighter-rouge">1*6+2*7+3*8+4*5</code>, 4차항은 <code class="language-plaintext highlighter-rouge">2*6+3*7+4*8+1*5</code>, 5차항은 .. 로 우리가 구하려했던 곱의 합들임을 확인할 수 있다.</p>

<p>즉, 결과의 n ~ 2n차항 중에 최댓값을 구해주면 된다.</p>

<h2 id="예제-2--보석-가게">예제 2 : 보석 가게</h2>

<p><a href="https://www.acmicpc.net/problem/13575">보석가게</a> 문제는 분할정복을 이용한 거듭제곱에 FFT를 적용하면 해결할 수 있다.</p>

<p>key idea는 다음과 같다.</p>

<p>input</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 a
1 2 3
</code></pre></div></div>
<p>위와 같을 경우 ${1 + 2x + 3x^2}$을 a번 곱했을 때 0이 아닌 계수의 수를 구해주면 된다.</p>

<p>단 분할 정복을 이용해 복잡도를 ${m}$에서 ${\log m}$으로낮추고, 큰 계수의 곱셈으로 인한 시간낭비를 막기 위해 계수를 0 or 1로 바꿔주면 된다.</p>

<p>분할 정복을 위한 거듭제곱을 이해하고 싶다면 <a href="https://www.acmicpc.net/problem/1629">이 문제</a>를 먼저 해결해보자.</p>

<h2 id="예제-3--rock-paper-scissors">예제 3 : Rock Paper Scissors</h2>

<p><a href="https://www.acmicpc.net/problem/14958">가위바위보</a> 문제는 각 ‘R’, ‘S’, ‘P’를 one hot encoding을 통해 바꿔서 해결할 수 있다.</p>

<p>예를 들자면 아래처럼 해준뒤, 언제 최대 승리가 나오는지 구해주면 된다.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">RSP</span> <span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">ur</span><span class="p">)</span> <span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">elt</span> <span class="o">==</span> <span class="n">pr</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">nn</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">elt</span> <span class="o">==</span> <span class="n">ur</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">brr</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    
    <span class="n">a_fft</span><span class="p">,</span> <span class="n">b_fft</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">fft</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">c_fft</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a_fft</span><span class="p">,</span> <span class="n">b_fft</span><span class="p">)]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">ifft</span><span class="p">(</span><span class="n">c_fft</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">real</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">c</span>

<span class="n">rock</span> <span class="o">=</span> <span class="n">RSP</span><span class="p">(</span><span class="s">'S'</span><span class="p">,</span> <span class="s">'R'</span><span class="p">)</span>
<span class="n">scissors</span> <span class="o">=</span> <span class="n">RSP</span><span class="p">(</span><span class="s">'P'</span><span class="p">,</span> <span class="s">'S'</span><span class="p">)</span>
<span class="n">paper</span> <span class="o">=</span> <span class="n">RSP</span><span class="p">(</span><span class="s">'R'</span><span class="p">,</span> <span class="s">'P'</span><span class="p">)</span>
</code></pre></div></div>

<p>오늘은 여기까지 !</p>]]></content><author><name>Jaehyun Kim</name></author><category term="algo" /><category term="FFT" /><category term="신호및시스템" /><category term="복소함수론" /><category term="백준" /><category term="추가예정" /><summary type="html"><![CDATA[Fourier Series &amp; Transfrom Review]]></summary></entry><entry><title type="html">[JAVA] 메모리 관리 - Garbage Collection</title><link href="http://localhost:4000/java/Java-heap-stack/" rel="alternate" type="text/html" title="[JAVA] 메모리 관리 - Garbage Collection" /><published>2022-07-22T00:00:00+09:00</published><updated>2022-07-22T00:00:00+09:00</updated><id>http://localhost:4000/java/%5BJava%5D-heap-stack</id><content type="html" xml:base="http://localhost:4000/java/Java-heap-stack/"><![CDATA[<blockquote>
  <p>Unreachable Object들은 Garbage Collector에 의해 회수된다.</p>
</blockquote>

<p>위의 내용을 이해하기 위해 JAVA에서의 메모리 관리 방법에 대해 살펴보자. 아래 reference들의 흐름을 따라 살을 붙이는 방식으로 작성했다.</p>

<p>일단 간략하게 stack과 heap의 특성을 요약해보자.</p>

<h2 id="stack">Stack</h2>

<ol>
  <li>Heap에 할당된 object들의 reference가 할당된다.</li>
  <li>value type(primitive type)들이 직접 저장된다.</li>
  <li>stack의 변수들은 <strong>특정한 visibility</strong>(scope)가 있다.</li>
  <li>Thread마다 독립 stack 공간을 가진다.</li>
  <li>LIFO</li>
</ol>

<p>scope는 쉽게 말해 변수가 선언된 블록 단위라고 보면 된다. 소속된 괄호가 닫히면 모두 pop되어 회수된다.</p>

<h2 id="heap">Heap</h2>

<ol>
  <li>실제 object들이 저장되고, stack에 의해 reference 된다.</li>
  <li>process 당 하나의 heap 공간. 즉 Thread들이 공유함.</li>
  <li>FIFO</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
</code></pre></div></div>

<p>보통 위와 같은 방법으로 object를 생성하는데, 이때 new 키워드가 heap에 충분한 공간이 있는지 확인하고 생성한다.</p>

<h2 id="생각해볼것">생각해볼것</h2>

<h3 id="사례-1">사례 1</h3>

<p>call by value 개념을 되짚어보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"jaehyun"</span><span class="o">;</span>
        <span class="n">oneFunction</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">};</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">oneFunction</span><span class="o">(</span><span class="nc">String</span> <span class="n">param</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">param</span> <span class="o">+=</span> <span class="s">" kim"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>지금까지 배운내용을 토대로 이걸 실행하면 다음과 같은 과정이 일어난다고 해석할 수 있다.</p>

<ol>
  <li>힙에 <code class="language-plaintext highlighter-rouge">"jaehyun"</code> 오브젝트가 생성되고 s가 스택영역에서 이를 reference한다.</li>
  <li><code class="language-plaintext highlighter-rouge">oneFunction</code> 함수를 실행하며 param 변수가 <code class="language-plaintext highlighter-rouge">"jaehyun"</code>오브젝트를 같이 reference하도록 한다. (call by value)</li>
  <li>함수안에서 <code class="language-plaintext highlighter-rouge">+</code>연산을 수행하므로, heap공간에 새로운 공간을 할당하고 새로운 string 오브젝트 <code class="language-plaintext highlighter-rouge">"jaehyun kim"</code>이 생성된다. param은 이걸 refer하고 있다. heap에 있던 기존의 <code class="language-plaintext highlighter-rouge">"jaehyun"</code>은 주인없이 떠다닌다,,</li>
  <li>함수가 종료되면 <code class="language-plaintext highlighter-rouge">"jaehyun kim"</code>을 reference하던 param변수가 스택에서 pop되고, 결국 heap에 저장된 <code class="language-plaintext highlighter-rouge">"jaehyun kim"</code>을 refer하는 변수도 없어졌다!</li>
  <li>하지만, s변수는 처음부터 계속 <code class="language-plaintext highlighter-rouge">"jaehyun"</code>을 refer하고 있었으므로, 그상태 그대로 남아있다.</li>
</ol>

<p>3, 4번에서 주인없이 떠다니는 애들은 어떻게 될까?</p>

<h3 id="사례-2">사례 2</h3>

<p>아래처럼 계속 생성하면 어떻게 될까?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"ABC"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>일단 지금까지 배운 내용으로 위를 해석해보자.</p>

<p><code class="language-plaintext highlighter-rouge">"ABC"</code>는 object이므로 이 string은 heap 어딘가에 저장되어 각각 <code class="language-plaintext highlighter-rouge">x</code>라는 stack에 있는 변수에 의해 reference 되어 있다.</p>

<p>그렇다면 언젠가 memory error가 뜰까?</p>

<p>그렇지는 않다. 우리의 <strong>Garbage Collector</strong>가 열일해서 다 회수했기 때문이다. (자세히 보면 이전에 생성된 object에 일반적인 방법으로는 접근할 수 있는 방법이 없을을 볼 수 있다.)</p>

<h2 id="garbage-collector">Garbage Collector</h2>

<p>이제 진짜 GC에 대해 알아보자. 먼저 뭘하는 애인지를 알아보고, 어떻게 작동하는지 살펴보자.</p>

<p>C언어를 배웠다면 메모리를 직접 malloc, free를 해주면서 관리해줬을텐데, java나 python을 쓰면서는 메모리 관리를 직접 신경 쓴 경험(mle같은거 말고)이 거의 없을 것이다. 왜냐면 JVM에 탑재된 Garbage Colletor가 잘 작동되고 있기 때문인데, 덕분에 덜 머리아프게 개발을 할 수 있다. GC가 동작하게된 배경은 다음과 같은 상황이 경험적으로 빈번하기 때문이다.</p>

<ol>
  <li>대부분의 object는 금방 필요없어진다.</li>
  <li>오래된 obj는 최근에 생성된 obj를 거의 참조하지 않는다.</li>
</ol>

<p>일단 뭔지 알아보자. 앞에서 이렇게 말했었다.</p>

<blockquote>
  <p>Unreachable Object들은 Garbage Collector에 의해 회수된다.</p>
</blockquote>

<p>여기서 unreachable object란 접근할 수 없는 object, 즉, 위의 사례1에서는 param이 <code class="language-plaintext highlighter-rouge">+</code>가 되기 전에 heap에 있던 <code class="language-plaintext highlighter-rouge">"jaehyun"</code> object가 <code class="language-plaintext highlighter-rouge">+</code>이후로는 더 이상 param에 의해 refer되지 않으므로 어떤 stack 변수로도 해당 object에 접근할 수 없는, unreachable object가 되는 것이다. 그리고 곧, 함수가 종료되면 param도 unreachable object가 되어 얘도 garbage가 된다. 이런애들이 GC에 의해 회수된다고 볼 수 있다.</p>

<p>이 과정은 <strong>Mark and Sweep</strong>으로 진행된다. 꽤나 단순한 방법인데 아래와 같은 순서로 진행된다.</p>

<ol>
  <li>Root하나를 잡는다. stack에 있는 변수들, 실행중인 스레드, JNI 레퍼 등등 root가 될만한 것들.</li>
  <li>Root로부터 트리 서치를 하면서 참조되고 있는 object들을 <strong>mark</strong>한다.</li>
  <li>mark되지 않은 object들을 <strong>sweep</strong>(해제)한다.</li>
</ol>

<p>생각보다 단순하게 작동해서 싱거운 맛이 없지 않다. 심지어 직접 mark를 해주는 과정때문에 오버헤드가 상당하지 않을까하는 걱정도 든다. 만약 서치를 하는데 loop가 요상하게 있으면 어떡하지(ps를 한창 풀다보니 드는 생각)?</p>

<p>실제로, 똑똑하신 Java GC 설계자님들께서 이를 해결하기 위한 여러 장치들을 설계해 놓으셨다.</p>

<p>예를 들자면, Young/Old Generation 영역으로 메모리를 분할한다던지, 다양한 Type(serial GC, Parallel GC, …)의 GC를 설계해놓는다던지 하는 것들이다.</p>

<p>더 적고 싶은 내용이 많지만 이번에는 여기까지!</p>

<h2 id="references">references</h2>

<p><a href="https://dzone.com/articles/java-memory-management">DZone</a></p>

<p><a href="https://rebelsky.cs.grinnell.edu/Courses/CS302/99S/Presentations/GC/">Grinnell Edu</a></p>]]></content><author><name>Jaehyun Kim</name></author><category term="JAVA" /><category term="Garbage Colletion" /><category term="cs" /><summary type="html"><![CDATA[Unreachable Object들은 Garbage Collector에 의해 회수된다.]]></summary></entry><entry><title type="html">인간관계의 법칙</title><link href="http://localhost:4000/book/Book-the-art-of-seduction/" rel="alternate" type="text/html" title="인간관계의 법칙" /><published>2022-07-20T00:00:00+09:00</published><updated>2022-07-20T00:00:00+09:00</updated><id>http://localhost:4000/book/%5BBook%5D-the-art-of-seduction</id><content type="html" xml:base="http://localhost:4000/book/Book-the-art-of-seduction/"><![CDATA[<h2 id="후기">후기</h2>

<p>.</p>

<h4 id="추천하는-독자">추천하는 독자</h4>

<h4 id="추천하지-않는-독자">추천하지 않는 독자</h4>

<p>all</p>]]></content><author><name>Jaehyun Kim</name></author><category term="book" /><category term="social" /><summary type="html"><![CDATA[후기]]></summary></entry><entry><title type="html">[JAVA] 클래스/인스턴스 변수/메서드의 구분</title><link href="http://localhost:4000/java/Java-study/" rel="alternate" type="text/html" title="[JAVA] 클래스/인스턴스 변수/메서드의 구분" /><published>2022-07-19T00:00:00+09:00</published><updated>2022-07-19T00:00:00+09:00</updated><id>http://localhost:4000/java/%5BJava%5D-study</id><content type="html" xml:base="http://localhost:4000/java/Java-study/"><![CDATA[<p>코테 언어 3대장 중 초심자가 봤을 때 가장 어려워보이는 언어는 자바가 아닐까 싶다. C 조금 하다가 파이썬 원툴로 잘 살아왔지만 회사에서 자바를 쓰기 때문에.. 그리고 앞으로 자바민국에서 살아가기 위해 나도 자바 공부를 시작했는데, 이것도 정리하면서 공부하면 용어를 좀더 오래 기억하는데도움이 되지 않을까 싶어 정리해보기로 했다.</p>

<h2 id="필드에서의-구분">필드에서의 구분</h2>

<ul>
  <li>class variable (클래스 변수, static 변수)</li>
  <li>instance variable (인스턴스 변수)</li>
  <li>local variable (지역 변수)
static/instance 변수들의 초깃값은 적절히 설정되어 있음.</li>
</ul>

<p>앞에 static 냅다 붙어있으면 class variable 되는거다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"><center>타입</center></th>
      <th style="text-align: center"><center>생성시기</center></th>
      <th style="text-align: right"><center>소멸시기</center></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>class</strong></td>
      <td style="text-align: center"><center>클래스가 메모리에 로드될 때</center></td>
      <td style="text-align: right"><center>프로그램이 종료될 때 </center></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>instance</strong></td>
      <td style="text-align: center"><center>인스턴스가 생성될 때</center></td>
      <td style="text-align: right"><center> 인스턴스가 소멸할때/GC가 수거할 때 </center></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>local</strong></td>
      <td style="text-align: center"><center>블록 내의 변수 선언문이 실행될 때</center></td>
      <td style="text-align: right"><center> 블록을 벗어날 때 </center></td>
    </tr>
  </tbody>
</table>

<p>class 변수는 instance를 생성하기 전부터 이미 메모리(method영역)에 로드되어 있다. 때문에, 해당 클래스의 모든 instance는 같은 값을 가지게 된다. 따라서, shared variable(공유 변수)라고도 불림. 사실 이 문단만 기억하면 될듯.</p>

<p>instance 변수는 heap영역에 저장되어 instance마다 개별 지정 가능.</p>

<p>local 변수는 stack에 저장됨.</p>

<h3 id="예시">예시</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">500</span><span class="o">;</span> <span class="c1">// instance variable</span>
  <span class="kd">static</span> <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="err">'</span><span class="n">ionic</span><span class="err">'</span><span class="o">;</span> <span class="c1">// static variable</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[]){</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// local variable</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="메소드에서의-구분">메소드에서의 구분</h2>

<ul>
  <li>class method (클래스 메소드, static method)</li>
  <li>instance method (인스턴스 메소드)</li>
</ul>

<p>비슷하게 static 키워드가 달려있으면 클래스되는거고 없으면 인스턴스되는 것이다. 또 비슷하게 class method는 instance 생성 전부터 사용가능하다.</p>

<p>따라서, class method는 instance variable을 사용할 수 없는데, 생각해보면 class들은 바로 생기지만 instance들은 instance가 할당되어야 시작되므로 순서가 꼬이지 않기 위해서 그렇다고 보면 된다.</p>

<p>따라서, method가 instance method/variable을 사용하지 않으면 보통 class method로 해준다고 한다.</p>

<h3 id="예시-1">예시</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
  <span class="kt">boolean</span> <span class="n">door</span><span class="o">;</span>
  <span class="kt">void</span> <span class="nf">openDoor</span><span class="o">(){</span> <span class="c1">// instance method</span>
    <span class="n">door</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="kd">static</span> <span class="kt">void</span> <span class="nf">toggleDoor</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// class method</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">d</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p>각 변수가 어떻게 저장되는지 더 찾아보다가 JAVA에서 GC가 메모리를 어떻게 관리하는지에 대해 공부하게 되었는데 다음 포스트에서 다룰 예정이다.</p>]]></content><author><name>Jaehyun Kim</name></author><category term="JAVA" /><category term="JAVA" /><category term="cs" /><summary type="html"><![CDATA[코테 언어 3대장 중 초심자가 봤을 때 가장 어려워보이는 언어는 자바가 아닐까 싶다. C 조금 하다가 파이썬 원툴로 잘 살아왔지만 회사에서 자바를 쓰기 때문에.. 그리고 앞으로 자바민국에서 살아가기 위해 나도 자바 공부를 시작했는데, 이것도 정리하면서 공부하면 용어를 좀더 오래 기억하는데도움이 되지 않을까 싶어 정리해보기로 했다. 필드에서의 구분 class variable (클래스 변수, static 변수) instance variable (인스턴스 변수) local variable (지역 변수) static/instance 변수들의 초깃값은 적절히 설정되어 있음. 앞에 static 냅다 붙어있으면 class variable 되는거다. 타입 생성시기 소멸시기 class 클래스가 메모리에 로드될 때 프로그램이 종료될 때 instance 인스턴스가 생성될 때 인스턴스가 소멸할때/GC가 수거할 때 local 블록 내의 변수 선언문이 실행될 때 블록을 벗어날 때 class 변수는 instance를 생성하기 전부터 이미 메모리(method영역)에 로드되어 있다. 때문에, 해당 클래스의 모든 instance는 같은 값을 가지게 된다. 따라서, shared variable(공유 변수)라고도 불림. 사실 이 문단만 기억하면 될듯. instance 변수는 heap영역에 저장되어 instance마다 개별 지정 가능. local 변수는 stack에 저장됨. 예시 class Car { int limit = 500; // instance variable static String name = 'ionic'; // static variable public static void main(String args[]){ int a = 1; // local variable } } 메소드에서의 구분 class method (클래스 메소드, static method) instance method (인스턴스 메소드) 비슷하게 static 키워드가 달려있으면 클래스되는거고 없으면 인스턴스되는 것이다. 또 비슷하게 class method는 instance 생성 전부터 사용가능하다. 따라서, class method는 instance variable을 사용할 수 없는데, 생각해보면 class들은 바로 생기지만 instance들은 instance가 할당되어야 시작되므로 순서가 꼬이지 않기 위해서 그렇다고 보면 된다. 따라서, method가 instance method/variable을 사용하지 않으면 보통 class method로 해준다고 한다. 예시 class Car { boolean door; void openDoor(){ // instance method door = true; } static void toggleDoor(boolean d) { // class method return !d; } } 각 변수가 어떻게 저장되는지 더 찾아보다가 JAVA에서 GC가 메모리를 어떻게 관리하는지에 대해 공부하게 되었는데 다음 포스트에서 다룰 예정이다.]]></summary></entry><entry><title type="html">[PRML] 11장 표집법</title><link href="http://localhost:4000/ml/PRML-11-sampling-methods/" rel="alternate" type="text/html" title="[PRML] 11장 표집법" /><published>2022-07-15T00:00:00+09:00</published><updated>2022-07-15T00:00:00+09:00</updated><id>http://localhost:4000/ml/%5BPRML%5D-11-sampling-methods</id><content type="html" xml:base="http://localhost:4000/ml/PRML-11-sampling-methods/"><![CDATA[<h2 id="개요">개요</h2>

<p>10장에서는 <strong>결정적 근사</strong>를 기반으로한 추론 알고리즘을 배웠다면, 이번 장에서는 <strong>수치적 표집법</strong>에 기반을 둔 근사 추론법인 Monte Carlo 테크닉에 대해 다룬다.</p>

<hr />

<p>운이 좋다면 latent variable에 대한 사후분포를 직접적으로 구할 수 있겠지만 사실은 대부분의 경우 분포의 기댓값 정보만 필요로 한다. 따라서 이번 장에서는 기댓값만 관심을 가져보자. 연속 변수일 때는 다음과 같이 기댓값이 표현된다(이산일 때는 sum으로)</p>

\[E[f] = \int f(z)p(z)dz\]

<p>이번 단원에서는 이 적분을 구하기 복잡한 상황에서 어떻게 표집법을 활용해 기댓값을 얻어낼 것인지에 대해 다루는데, 이 idea는 분포 ${p(z)}$로 부터 독립적으로 표본 집합 ${z^{(l)}}$을 얻어내는 것에서 시작한다! 독립적으로 잘 뽑았다고 하면 다음과 같이 기댓값을 바꿔줄 수 있다. 물론 근사치이다.</p>

\[\hat{f} = \frac{1}{L}\sum_{l \in L}{f(z)^{(l)}}\]

<p>이 추정량의 분산은 공식에 의해 다음과 같이 나타낼 수 있다.</p>

\[var[\hat{f}] = \frac{1}{L}E[(f-E[f])^2]\qquad{(11.3)}\]

<p>놀라운 점은 실제로 10~20개 정도의 샘플로 기댓값을 꽤 정확하게 얻어낼 수 있다고 한다. 다만 당연하게도 이 샘플들을 <strong>독립적</strong>으로 얻어내는 것이 
중요하다.</p>

<hr />

<p>방향성 그래프(directed acyclic graph)의 경우 8장에서 다룬 ancestral sampling 기법을 단순히 적용해주면 될 것이다.</p>

<p>그런데, observed node가 존재할 경우 어떻게 할까? 생각해볼 수 있는 가장 단순한 방법은 똑같이 ancestal sampling을 사용하되, 관찰값과 다를 경우 버리고 같을 경우에만 가져가는 방식을 취해주는 방식이다. 물론 observed node들이 늘어날 수록 버리는 경우가 늘어나기 때문에, 실제로 잘 쓰이지는 않는다.</p>

<h2 id="111-기본적인-표집-알고리즘">11.1 기본적인 표집 알고리즘</h2>

<p>가장 단순한 방법으로 내장된 rand 함수를 통해 쉽게 구현할 수 있는 방법을 소개한다. 여기서 rand 함수가 독립적인 난수를 생성한다고 가정하자. <del><a href="https://en.wikipedia.org/wiki/Random_number_generation">사실은 그렇지 않다고 알려져 있다</a>.</del></p>

<h3 id="1111-표준분포">11.1.1 표준분포</h3>

<p>단일 변수 확률 분포 ${p(z)}$가 존재할 때 어떻게 표집하면 분포를 따라갈 수 있을지 생각을 먼저해보자.</p>

<p>당연하게도 확률이 높은 부분일 수록 많이 뽑히고, 적은 부분일 수록 적게 뽑혀야할 것이다. 확률 분포(pdf)의 누적 확률 분포(cdf)를 생각해보면, 높은 확률을 가지는 구간에서는 높은 기울기를 가질 것이다. 그렇다면 여기서 어떻게 추출하면 될까? cdf는 0~1의 함숫값을 가지고 있다는 사실로부터 힌트를 얻을 수 있다. 바로 cdf의 y축(0~1)에서 random sampling을 해주면 될 것이다.즉, 역함수의 정의역에서 샘플을 취해주면 된다는 것이다. 느낌으로는 꽤나 직관적인데 이를 증명해보면 아래와 같이 간단히 나타낼 수 있다.</p>

\[since \quad F^{-1}(u) = inf\{x \mid F(x) \geq u\} \quad \forall u \in [0,1]\]

\[P(F^{-1}(U) \leq x) = P(Y \leq F(x)) = F(x)\]

<p>마지막 등호는 ${U}$가 uniform하기 때문에 성립한다.</p>

<p>따라서 ${F^{-1}(U)}$의 cdf는 ${F(x)}$와 같은 분포이며, continuous pdf와 cdf는 1to1 correspondence가 보장되므로 증명이 완료된다.</p>

<p>단일변수에 대해 다뤘으므로 다변수에 대해서도 다룰 수 있는데, 독립 변수의 경우에는 단일 변수일 때와 마찬가지로 각각에 대해 inverse cdf를 구해서 sampling을 진행하면 된다. 책에서는 gaussian integral을 활용한 다변수 분포의 간소화 예시인 Box-Muller Method를 소개하는데, 마치 모든 다변수에서 그러는 것처럼 설명되어 있다.</p>

<p>uniform한 ${U_1, U_2}$가 주어져있을 때, Gaussian 분포를 따르는 ${z_1, z_2}$를 어떻게 구할지 생각해보자(이부분은 굳이 안봐도 될듯).</p>

<p><strong>첫번째 방법</strong></p>

<p>앞서 설명한 가장 단순한 방법은 각자 inverse cdf를 구해주는 방법이다. cdf는 다음과 같다.</p>

\[F(z)= \frac{1}{\sqrt{2 \pi}} \int_{-\infty}^{z}\exp\left\{-\frac{u^2}{2}\right\} du\]

<p>inverse를 구해주면, 아래와 같다. erfinv는 <a href="https://en.wikipedia.org/wiki/Error_function#:~:text=Inverse%20functions,-Inverse%20error%20function&amp;text=For%20real%20x%2C%20there%20is,defined%20as%20erfi%E2%88%921%20x.&amp;text=where%20ck%20is%20defined%20as%20above.">여기</a>를 참고</p>

\[F^{-1}(U) = \sqrt{2}\: \textbf{erfinv} (2U-1)\]

<p>여기서 ${U_1, U_2}$를 사용해 각 ${z_1, z_2}$를 구할 수 있다.</p>

<p><strong>두번째 방법</strong></p>

<p>erf는 anayltic하지 않은 영 좋지 않은 함수이기에 gaussian integral에서 배운 극좌표 변환 테크닉을 이용해 간단해질 수 있다. ${z}$를 2차원 평면에 두고 ${U}$들이 ${r}$과 ${\theta}$를 표현하도록 적절히 변환해주면 될 것이다. 그 과정은 아래와 같다.</p>

\[\begin{aligned}f(z_1, z_2) &amp;= f(z_1)f(z_2) \\ 
&amp;= \frac{1}{\sqrt{2\pi}} \exp \left\{-\frac{z_1^2}{2}\right\} \frac{1}{\sqrt{2\pi}} \exp \left\{-\frac{z_2^2}{2}\right\} \\
&amp;= \frac{1}{2 \pi} \exp \left\{\frac{z_1^2 + z_2^2}{2}\right\} \end{aligned}\]

<p>여기서 아래와 같이 둔다.</p>

\[z_1 = \sqrt{2} s \cos(\theta) \\z_2=\sqrt{2} s\sin(\theta)\]

<p>그러면, 아래와 같이 단순해진다.</p>

\[f(z_1,z_2) = \frac{1}{2\pi}e^{-s}\]

<p>즉 두 pdf의 곱으로 생각할 수 있고 각각에 대해 inverse cdf를 구해주면 다음과 같다.</p>

\[\begin{aligned}\theta &amp;= 2\pi U_1 \\ r &amp;= -\ln(1-U_2)\end{aligned}\]

<p>즉, 우리의 목표인 ${z_1, z_2}$는 다음과 같이 구해진다.</p>

\[z_1 = \sqrt{-2\ln(U_1)} \cos (2\pi U_2) \\ z_2 = \sqrt{-2\ln(U_1)} \sin (2\pi U_2)\]

<p>uniform 만 잘 뽑혔다면 두 방법은 완전히 같은 결과를 보여준다.</p>

<p>이번 경우는 운이 좋은 경우였고, 그렇지 않은 경우들에 대해 일반적인 방법이 필요하다. 특별히 단변량 분포에 대해서는 rejection sampling과 importance sampling 기법이 있는데 이에 대해 알아보자.</p>

<h3 id="1112-거부-표집법-rejection-sampling">11.1.2 거부 표집법 (Rejection Sampling)</h3>

<p>일반적인 분포 ${p(z)}$에서 표집을 할때 사용하는 간단한 기법이다.</p>

<ol>
  <li>${p(z)}$와 개형이 최대한 비슷한 적절하게 해석적인 함수 ${q(z)}$를 잡는다.</li>
  <li>모든 구간에서 ${kq(z) \geq p(z)}$를 만족하는 상수 ${k}$를 구한다. 작을수록 좋다!</li>
  <li>${q(z)}$를 앞서 배운 방법들로 sampling해 ${z_0}$를 얻는다.</li>
  <li>구간 ${[0, kq(z_0)]}$에서 uniform sampling을 해 ${u)0}$를 얻는다.</li>
  <li>만약 ${u_0 &gt; p(z)}$면 버리고(reject) 그렇지 않다면 유지한다.</li>
</ol>

<p><img width="471" alt="20220709" src="https://user-images.githubusercontent.com/40457043/180615286-324f9f41-cfdf-487e-9d6d-c62f323d9ccd.png" /></p>

<h3 id="1113-적응적-거부-표집법">11.1.3 적응적 거부 표집법</h3>

<p>적절한 ${q(z)}$를 찾는것이 어려울 경우를 위한 방법(야매)이다.</p>

<p>먼저, ${\ln(p(z))}$가 오목함수인 경우에는 단순히 <a href="https://en.wikipedia.org/wiki/Linear_interpolation">line interpolation method</a>로 해결이 가능하다. numerical analysis 첫시간에 배우는 무식한 방법이지만 빠르고 좋은 방법이다. 여기서도 볼줄이야. 당연히 수집하는 point의 수가 늘어날 수록 ${p(z)}$와 ${q(z)}$가 비슷해질 것이며 rejection rate도 줄어들 것이다.</p>

<ul>
  <li>각 point에서 미분이 정의되지 않는데 변형 알고리즘이 존재한다고 한다.</li>
  <li>로그 오목이 아닐경우 11.2.2에서 살펴본다. aka Adaptive Rejection Metropolis Sampling</li>
  <li>고차원 공간에서는 acception rate가 기하급수적으로 감소하기 때문에 이를 개선하기 위해 복잡도가 급격히 증가하기에 사용하기 어렵다.</li>
</ul>

<h3 id="1114-중요도-표집법">11.1.4 중요도 표집법</h3>

<p>역시 표집하기 어려운 분포가 주어졌다고 가정하고 기닷갮 ${E(z)}$를 구해보자.</p>

<p>이번에도 새로운 분포 ${q(z)}$를 두고 일단 샘플링을 해서 ${z^l}$들을 얻어내고 해당 ${z^l}$에서 ${\frac{p(z)}{q(z)}}$만큼의 weight를 주고 기댓값을 계산해주는 방식이다. 기본 idea는 Rejection Sampling과 다를바 없어 보인다.</p>

<p>논리대로 식을 전개해보자면 다음과 같다.</p>

\[E[f] = \int f(z)p(z)dz = \frac{Z_q}{Z_p}\int f(z)\frac{\tilde{p}(z)}{\tilde{q}(z)}q(z)dz \simeq \frac{Z_q}{Z_p}\frac{1}{L} \sum_{l=1}^{L} \tilde{r}_{l} f(z^{(l)})\]

<p>마찬가지로 ${q(z)}$가 얼마나 ${p(z)}$와 비슷한 분포를 가지는지, ${p(z)}$의 자연스러운 분포 여부(적당히 생긴)에 따라 기댓값의 정확도가 상승한다.</p>

<ul>
  <li>그래프 모델에서는 여기에 마르코프한 가중치를 덮어주면 된다. 또한, 이를 발전시킨 형태로 Likelihood Weighted Sampling(가능도 가중 표집법)이 존재한다. 이는 Ancestral Sampling(조상 표집법)을 적용한 형태로 진행. 더 나아가 Self Importance Sampling(자가 중요도 표집법)도 있는데 그만 알아보자.</li>
</ul>

<h3 id="1115-표집-중요도-재표집">11.1.5 표집 중요도 재표집</h3>

<p>Rejection Sampling을 할때 ${k}$를 구하는 과정이 있었는데, 이 과정을 생략해주는 방법이다.</p>

<ol>
  <li>${q(z)}$로부터 ${z^l}$을 추출한다.</li>
  <li>각 ${z^l}$에 대한 가중치 ${w_l}$을 계산한다.</li>
  <li>각각의 확률이 ${w_l}$을 가지는 이산 분포 ${z^l}$들로부터 다시 ${L}$개를 추출한다.</li>
</ol>

<p>결국 Rejection Sampling에 Importance Sampling을 덮어준 형태인데, 기본 idea는 같은 것이라 크게 발전된 형태로 보이지는 않는다.</p>

<h3 id="1116-표집법과-em-알고리즘">11.1.6 표집법과 EM 알고리즘</h3>

<p>EM을 사용할 때, E단계에서 non-analytic한 함수를 만났을 경우 표집법을 통한 근사로 해결이 가능하다.</p>

<p>즉, 적분꼴로 표현된 최적화 대상을 이산 합 형태로 아래와 같이 바꿔주는 것이다.</p>

\[Q(\theta, \theta^{old}) = \int p(\textbf{Z} | \textbf{X} , \theta^{old}) \ln p(\textbf{Z},\textbf{X} | \theta) \, d\textbf{Z}\]

\[to\]

\[Q(\theta, \theta^{old}) \approx \frac{1}{L} \sum \ln p(\textbf{Z}^{(l)}, \textbf{X} \bar \theta )\]

<p>이 과정을 Monte Carlo EM algorithm이라고 부른다.</p>

<p>참고) IP 알고리즘</p>

<p>${p(\textbf{Z} \mid \textbf{X})}$에서 표집이 어려운 상황에서 Maximum Likelihood 대신 Bayesian하게 접근해서 해결하는 방법.</p>

<ul>
  <li>I Step</li>
</ul>

\[p(\textbf{Z} | \textbf{X}) = \int p(\textbf{Z} | \textbf{X} , \theta) p(\theta | \textbf{X}) \, d\theta\]

<p>순서대로 ${\textbf{X}}$로부터 ${\theta ^{(l)}}$들을 추출하고 이들의 결합분포를 통해 ${p(\textbf{Z} \mid \textbf{X} , \theta)}$에서 ${\textbf{X}}$를 추출한다.</p>

<ul>
  <li>P Step</li>
</ul>

\[p(\theta | \textbf{X}) = \int p(\theta | \textbf{Z} , \textbf{X}) p(\textbf{Z} | \textbf{X}) \, d\textbf{Z}\]

<p>구한 ${\textbf{Z}}$들을 통해 ${\theta}$에 대한 사후분포식을 수정해준다.</p>

<h2 id="112-마르코프-연쇄-몬테-카를로">11.2 마르코프 연쇄 몬테 카를로</h2>

<p>MCMC는 Rejection Sampling이나 Importance Sampling과 비슷한 방식으로 진행되지만, 무조건 Reject되기 보다는 회생의 기회를 준다는점에서 차이가 있다. 물론 여기서 얻은 표본들도 독립이 아니지만, 충분히 큰 M에 대해 kM번째 샘플만 취해준다면 어느정도 독립성을 보장해줄 수 있다.</p>

<p>먼저, 가장 대표적인 방식인 Metropolis Algorithm에 대해 알아보자.</p>

<ol>
  <li>목표 분포 ${p(z)}$에 대해 Rejection Sampling때와 마찬가지로 적절한 ${q(z)}$를 잡아준다.
(Metropolis 알고리즘에서는 대칭(${q(z_A \mid z_B) = q(z_B \mid z_A)}$)임을 가정한다.)</li>
  <li>초깃값 ${z^{(1)}}$을 시작으로 ${q(z)}$ 에서 하나의 표본 ${z^*}$을 추출한다.</li>
  <li>Accept or Reject
    <ol>
      <li>${p(z^*) &gt; p(z^{(1)})}$일경우 accept</li>
      <li>그렇지 않을 경우, $\frac{p(z^*)}{p(z^{(1)})}$의 확률로 accept한다.</li>
      <li>이를 다시표현하면, ${min \left(1, \frac{p(z^*)}{p(z^{(1)})}\right)}$의 확률로 Accept한다.</li>
    </ol>
  </li>
</ol>

<p>이에 대한 증명은 적혀있지 않은데, <a href="https://hydthemoon.github.io/ml/PRML-%ED%91%9C%EC%A7%91%EB%B2%95/#1122-metropolis-hastings-algorithm">11.2.2</a>에서 일반화된 증명으로 살펴본다.</p>

<h3 id="1121-마르코프-연쇄">11.2.1 마르코프 연쇄</h3>

<p>다음 상태가 현재 상태에만 의존할 경우 마르코프하다고 한다.</p>

\[{ p(z^{(m+1)} \mid z^{(1)}, \ldots z^{(m)}) = p(z^{(m+1)}\mid z^{(m)} )}\]

<p>각 상태에서 ${T_{m}^{ij} = p(z^{(m+1)} = v_j \mid z^{(m)} = v_i) }$을 Transition Matrix라고 부르며 이 matrix가 ${m}$에 무관할 경우 Homogenous한 chain이라고 부른다.</p>

<p>최종적으로 ergodic 개념이 중요한데, 아래 세 조건은 동치이다.</p>

<ol>
  <li>Ergodic</li>
  <li>Positive Recurrent, Aperiodic</li>
  <li>Finite, Irreducible, Aperiodic</li>
</ol>

<p>즉, ergodic하면, 충분한 시간이 흐른 뒤 분포와 초기 분포가 동일한 분포가 된다.</p>

<p>또한, 헷갈리는 개념으로 stationary가 있는데, transition matrix ${T}$에 대해 ${\pi = \pi T}$를 만족할 때, 즉, 분포가 일정할 때 stationary(invariant)하다고 한다.</p>

\[p(z^{(m+1)}) = \sum p(z^{(m+1)} \mid z^{(m)}) p(z^{(m)})\]

<p>일반적으로 ergodic하면 stationary한 ${\pi}$가 존재하며 stationary하다.</p>

<p>자세한 내용이 궁금하다면 Stochastic Process를 공부해보자. 재밌는 책이다.</p>

<h3 id="1122-메트로폴리스-헤이스팅스-알고리즘">11.2.2 메트로폴리스 헤이스팅스 알고리즘</h3>

<p>앞선 Metropolis Algorithm은 대칭 ${q(z)}$만을 사용했는데, 한계가 있으므로 이번에는 좀더 일반적인 상황을 위한 해법을 살펴보자.</p>

<p>유일한 차이는 Accept or Reject할 때이다. 다음과 같이 acceptance rate를 정규화해주면 된다.</p>

\[rate_{z, z'} = min\left(1, \frac{\frac{p(z^*)}{q(z^* \mid z^m)}}{\frac{p(z^m)}{q(z^m \mid z^*)}} \right)\]

<p>이제 이렇게 얻은 표본집합이 ${p(z)}$에 수렴한다는 것을 증명해야한다. 책에는 좀 대충나와있는 것 같다.</p>

<p>일단, 각 표본들은 위의 rate를 따르는 MC라고 볼 수 있다. 나아가, acceptance rate를 통해 postivie recurrent함을 확인할 수 있고, 당연하게 Aperiodic하므로, Ergodic한 MC임을 쉽게 볼 수 있다. 따라서, unique한 stationary matrix ${\pi}$를 가짐을 알 수 있다. 이제, ${\pi}$가 ${p(x)}$에 수렴함을 보여야한다. 다음 식을 살펴보자.</p>

\[\begin{aligned}p(z)q(z'\mid z) * rate_{z, z'} &amp;= min\left(p(z)q(z'\mid z), p(z')q(z\mid z')\right) \\ &amp;= min\left(p(z')q(z\mid z'), p(z)q(z'\mid z)\right)  \\ &amp;= p(z')q(z\mid z') * rate_{z', z}\end{aligned}\]

<p>따라서, ${q(z)}$와 rate의 결합은 이 MC의 transition probability라고 볼 수 있으며, 결국 같은 ${\pi}$에 수렴함을 알 수 있다.</p>

<p>마찬가지로, 어떤 ${q(z)}$를 사용하는지에 따라 알고리즘의 성능에 현저한 영향을 줄 수 있다. 일반적으로 gaussian을 사용한다. 여기서 분산을 어떻게 두냐에 따른 trade-off가 있는데, 분산이 작을 경우 acceptance는 증가하지만, 전체를 탐색하기 오래걸리고, 분산이 클 경우 acceptance 자체가 낮아지게 된다. 따라서 그림 11.10과 같이 방향에 따라 분산의 차이가 클 경우 알고리즘이 느리게 수렴하게 된다.</p>

<h2 id="113-깁스-표집법">11.3 깁스 표집법</h2>

<p>알고보니 <a href="https://en.wikipedia.org/wiki/Gibbs_free_energy">Gibbs Free Energy</a>를 정의한 그 Gibbs이다. 이쪽업계 코시 같은 사람인듯;</p>

<p>아무튼 Gibbs Sampling은 MCMC의 한 종류이다. 방법은 간단한데, ${m}$개의 확률변수들이 결합된 결합확률분포가 있을 때, ${m - 1}$개의 변수를 고정시키고 남은 한개를 조건부 확률분포로 부터 표집하고, 다른 ${m-1}$개를 고정시키고 남은 한개를 표집하고 … 을 반복해서 얻어나가는 방법이다. 너무 rough하게 적은것 같으니 좀더 정확하게 설명하면 ${T}$회 반복하는 경우 아래와 같다.</p>

<ol>
  <li>initialize ${z_i : i = 1, \ldots M}$</li>
  <li>for ${i}$ in range (${1}$, ${T}$)
    <ol>
      <li>${p(z_1 \mid z_2^{i},z_3^{i},\ldots,z_M^{i})}$에서 ${z_1^{i+1}}$을 표집한다.</li>
      <li>${p(z_2 \mid z_1^{i+1},z_3^{i},\ldots,z_M^{i})}$에서 ${z_2^{i+1}}$을 표집한다.
${\vdots}$</li>
      <li>${p(z_M \mid z_1^{i+1},z_2^{i+1},\ldots,z_{M-1}^{i+1})}$에서 ${z_M^{i+1}}$을 표집한다.</li>
    </ol>
  </li>
</ol>

<p>여기서는 변수들에게 order를 부여하고 진행했는데, random한 order로 진행할 수도 있다. 물론 결과적으로는 같다.</p>

<p>이제, 이 기법이 올바른 샘플링임을 증명해보자. MH 알고리즘의 일종이라고 언급했으니 이게 왜 MH 알고리즘인지 증명해보면 된다. 좀 rough하게 살펴보자.</p>

<p>일단, 이 분포 또한 MH에서 사용한 분포와 같이 stationary함을 보여야한다. 이는 꽤나 자명한데, 각 표집에서 적절한 조건부 분포를 사용하기 때문이다. 즉, 적할한 ${\pi}$가 존재한다.</p>

\[\begin{aligned} rate &amp;= min\left( 1, \frac{p(z^*)q(z|z^*)}{p(z)q(z^*|z) } \right)\\ &amp;= min\left(1, \frac{p(z^*_k|z^*_{-k})p(z^*_{-k})p(z_k | z^*_{-k})}{p(z_k|z_{-k})p(z_{-k})p(z^*_{k}|z_{-k})} \right) \\ &amp;= min(1,1) = 1\end{aligned}\]

<p>즉, MH와 같은 rate를 가지고 있기 때문에, MH의 일종으로 볼 수 있다.</p>

<h2 id="114-조각-표집법">11.4 조각 표집법</h2>

<p>계속해서 보이는 알고리즘들의 단점은 ${p(z)}$와 ${q(z)}$의 차이에서 비롯되었다. 분산이 작으면 탐색이 느리고, 크면 acceptance가 낮아진다. 조각표집법(slice sampling)은 새로운 방식으로 해결하고자 했다.</p>

<p>아이디어는 간단한데, 아래와 같이 y축에서 쳐다보는 변수 ${u}$를 추가해서 해결하는 것이다.</p>

\[\hat p(z,u) =  \begin{cases} 1/Z_p &amp; 0 \leq u \leq \hat p(z) \\ 0 &amp; else \end{cases}\]

<p>그리고, 깁스 샘플링 같은 방법을 통해 ${\hat p(z,u)}$에서 표본을 얻고, ${u}$를 무시해주어 원 분포를 얻는 방식이다.</p>

<p>근데 이건 그냥 원래 있던 inverse cdf하는 방법보다도 원시적인 방법이 아닌가 싶다.</p>

<h2 id="115-하이브리드-몬테-카를로-알고리즘">11.5 하이브리드 몬테 카를로 알고리즘</h2>

<h2 id="116-분할-함수-추정">11.6 분할 함수 추정</h2>]]></content><author><name>Jaehyun Kim</name></author><category term="ML" /><category term="PRML" /><category term="표집법" /><category term="MCMC" /><category term="깁스 샘플링" /><summary type="html"><![CDATA[개요 10장에서는 결정적 근사를 기반으로한 추론 알고리즘을 배웠다면, 이번 장에서는 수치적 표집법에 기반을 둔 근사 추론법인 Monte Carlo 테크닉에 대해 다룬다. 운이 좋다면 latent variable에 대한 사후분포를 직접적으로 구할 수 있겠지만 사실은 대부분의 경우 분포의 기댓값 정보만 필요로 한다. 따라서 이번 장에서는 기댓값만 관심을 가져보자. 연속 변수일 때는 다음과 같이 기댓값이 표현된다(이산일 때는 sum으로) \[E[f] = \int f(z)p(z)dz\] 이번 단원에서는 이 적분을 구하기 복잡한 상황에서 어떻게 표집법을 활용해 기댓값을 얻어낼 것인지에 대해 다루는데, 이 idea는 분포 ${p(z)}$로 부터 독립적으로 표본 집합 ${z^{(l)}}$을 얻어내는 것에서 시작한다! 독립적으로 잘 뽑았다고 하면 다음과 같이 기댓값을 바꿔줄 수 있다. 물론 근사치이다. \[\hat{f} = \frac{1}{L}\sum_{l \in L}{f(z)^{(l)}}\] 이 추정량의 분산은 공식에 의해 다음과 같이 나타낼 수 있다. \[var[\hat{f}] = \frac{1}{L}E[(f-E[f])^2]\qquad{(11.3)}\] 놀라운 점은 실제로 10~20개 정도의 샘플로 기댓값을 꽤 정확하게 얻어낼 수 있다고 한다. 다만 당연하게도 이 샘플들을 독립적으로 얻어내는 것이 중요하다. 방향성 그래프(directed acyclic graph)의 경우 8장에서 다룬 ancestral sampling 기법을 단순히 적용해주면 될 것이다. 그런데, observed node가 존재할 경우 어떻게 할까? 생각해볼 수 있는 가장 단순한 방법은 똑같이 ancestal sampling을 사용하되, 관찰값과 다를 경우 버리고 같을 경우에만 가져가는 방식을 취해주는 방식이다. 물론 observed node들이 늘어날 수록 버리는 경우가 늘어나기 때문에, 실제로 잘 쓰이지는 않는다. 11.1 기본적인 표집 알고리즘 가장 단순한 방법으로 내장된 rand 함수를 통해 쉽게 구현할 수 있는 방법을 소개한다. 여기서 rand 함수가 독립적인 난수를 생성한다고 가정하자. 사실은 그렇지 않다고 알려져 있다. 11.1.1 표준분포 단일 변수 확률 분포 ${p(z)}$가 존재할 때 어떻게 표집하면 분포를 따라갈 수 있을지 생각을 먼저해보자. 당연하게도 확률이 높은 부분일 수록 많이 뽑히고, 적은 부분일 수록 적게 뽑혀야할 것이다. 확률 분포(pdf)의 누적 확률 분포(cdf)를 생각해보면, 높은 확률을 가지는 구간에서는 높은 기울기를 가질 것이다. 그렇다면 여기서 어떻게 추출하면 될까? cdf는 0~1의 함숫값을 가지고 있다는 사실로부터 힌트를 얻을 수 있다. 바로 cdf의 y축(0~1)에서 random sampling을 해주면 될 것이다.즉, 역함수의 정의역에서 샘플을 취해주면 된다는 것이다. 느낌으로는 꽤나 직관적인데 이를 증명해보면 아래와 같이 간단히 나타낼 수 있다. \[since \quad F^{-1}(u) = inf\{x \mid F(x) \geq u\} \quad \forall u \in [0,1]\] \[P(F^{-1}(U) \leq x) = P(Y \leq F(x)) = F(x)\] 마지막 등호는 ${U}$가 uniform하기 때문에 성립한다. 따라서 ${F^{-1}(U)}$의 cdf는 ${F(x)}$와 같은 분포이며, continuous pdf와 cdf는 1to1 correspondence가 보장되므로 증명이 완료된다. 단일변수에 대해 다뤘으므로 다변수에 대해서도 다룰 수 있는데, 독립 변수의 경우에는 단일 변수일 때와 마찬가지로 각각에 대해 inverse cdf를 구해서 sampling을 진행하면 된다. 책에서는 gaussian integral을 활용한 다변수 분포의 간소화 예시인 Box-Muller Method를 소개하는데, 마치 모든 다변수에서 그러는 것처럼 설명되어 있다. uniform한 ${U_1, U_2}$가 주어져있을 때, Gaussian 분포를 따르는 ${z_1, z_2}$를 어떻게 구할지 생각해보자(이부분은 굳이 안봐도 될듯). 첫번째 방법 앞서 설명한 가장 단순한 방법은 각자 inverse cdf를 구해주는 방법이다. cdf는 다음과 같다. \[F(z)= \frac{1}{\sqrt{2 \pi}} \int_{-\infty}^{z}\exp\left\{-\frac{u^2}{2}\right\} du\] inverse를 구해주면, 아래와 같다. erfinv는 여기를 참고 \[F^{-1}(U) = \sqrt{2}\: \textbf{erfinv} (2U-1)\] 여기서 ${U_1, U_2}$를 사용해 각 ${z_1, z_2}$를 구할 수 있다. 두번째 방법 erf는 anayltic하지 않은 영 좋지 않은 함수이기에 gaussian integral에서 배운 극좌표 변환 테크닉을 이용해 간단해질 수 있다. ${z}$를 2차원 평면에 두고 ${U}$들이 ${r}$과 ${\theta}$를 표현하도록 적절히 변환해주면 될 것이다. 그 과정은 아래와 같다. \[\begin{aligned}f(z_1, z_2) &amp;= f(z_1)f(z_2) \\ &amp;= \frac{1}{\sqrt{2\pi}} \exp \left\{-\frac{z_1^2}{2}\right\} \frac{1}{\sqrt{2\pi}} \exp \left\{-\frac{z_2^2}{2}\right\} \\ &amp;= \frac{1}{2 \pi} \exp \left\{\frac{z_1^2 + z_2^2}{2}\right\} \end{aligned}\] 여기서 아래와 같이 둔다. \[z_1 = \sqrt{2} s \cos(\theta) \\z_2=\sqrt{2} s\sin(\theta)\] 그러면, 아래와 같이 단순해진다. \[f(z_1,z_2) = \frac{1}{2\pi}e^{-s}\] 즉 두 pdf의 곱으로 생각할 수 있고 각각에 대해 inverse cdf를 구해주면 다음과 같다. \[\begin{aligned}\theta &amp;= 2\pi U_1 \\ r &amp;= -\ln(1-U_2)\end{aligned}\] 즉, 우리의 목표인 ${z_1, z_2}$는 다음과 같이 구해진다. \[z_1 = \sqrt{-2\ln(U_1)} \cos (2\pi U_2) \\ z_2 = \sqrt{-2\ln(U_1)} \sin (2\pi U_2)\] uniform 만 잘 뽑혔다면 두 방법은 완전히 같은 결과를 보여준다. 이번 경우는 운이 좋은 경우였고, 그렇지 않은 경우들에 대해 일반적인 방법이 필요하다. 특별히 단변량 분포에 대해서는 rejection sampling과 importance sampling 기법이 있는데 이에 대해 알아보자. 11.1.2 거부 표집법 (Rejection Sampling) 일반적인 분포 ${p(z)}$에서 표집을 할때 사용하는 간단한 기법이다. ${p(z)}$와 개형이 최대한 비슷한 적절하게 해석적인 함수 ${q(z)}$를 잡는다. 모든 구간에서 ${kq(z) \geq p(z)}$를 만족하는 상수 ${k}$를 구한다. 작을수록 좋다! ${q(z)}$를 앞서 배운 방법들로 sampling해 ${z_0}$를 얻는다. 구간 ${[0, kq(z_0)]}$에서 uniform sampling을 해 ${u)0}$를 얻는다. 만약 ${u_0 &gt; p(z)}$면 버리고(reject) 그렇지 않다면 유지한다. 11.1.3 적응적 거부 표집법 적절한 ${q(z)}$를 찾는것이 어려울 경우를 위한 방법(야매)이다. 먼저, ${\ln(p(z))}$가 오목함수인 경우에는 단순히 line interpolation method로 해결이 가능하다. numerical analysis 첫시간에 배우는 무식한 방법이지만 빠르고 좋은 방법이다. 여기서도 볼줄이야. 당연히 수집하는 point의 수가 늘어날 수록 ${p(z)}$와 ${q(z)}$가 비슷해질 것이며 rejection rate도 줄어들 것이다. 각 point에서 미분이 정의되지 않는데 변형 알고리즘이 존재한다고 한다. 로그 오목이 아닐경우 11.2.2에서 살펴본다. aka Adaptive Rejection Metropolis Sampling 고차원 공간에서는 acception rate가 기하급수적으로 감소하기 때문에 이를 개선하기 위해 복잡도가 급격히 증가하기에 사용하기 어렵다. 11.1.4 중요도 표집법 역시 표집하기 어려운 분포가 주어졌다고 가정하고 기닷갮 ${E(z)}$를 구해보자. 이번에도 새로운 분포 ${q(z)}$를 두고 일단 샘플링을 해서 ${z^l}$들을 얻어내고 해당 ${z^l}$에서 ${\frac{p(z)}{q(z)}}$만큼의 weight를 주고 기댓값을 계산해주는 방식이다. 기본 idea는 Rejection Sampling과 다를바 없어 보인다. 논리대로 식을 전개해보자면 다음과 같다. \[E[f] = \int f(z)p(z)dz = \frac{Z_q}{Z_p}\int f(z)\frac{\tilde{p}(z)}{\tilde{q}(z)}q(z)dz \simeq \frac{Z_q}{Z_p}\frac{1}{L} \sum_{l=1}^{L} \tilde{r}_{l} f(z^{(l)})\] 마찬가지로 ${q(z)}$가 얼마나 ${p(z)}$와 비슷한 분포를 가지는지, ${p(z)}$의 자연스러운 분포 여부(적당히 생긴)에 따라 기댓값의 정확도가 상승한다. 그래프 모델에서는 여기에 마르코프한 가중치를 덮어주면 된다. 또한, 이를 발전시킨 형태로 Likelihood Weighted Sampling(가능도 가중 표집법)이 존재한다. 이는 Ancestral Sampling(조상 표집법)을 적용한 형태로 진행. 더 나아가 Self Importance Sampling(자가 중요도 표집법)도 있는데 그만 알아보자. 11.1.5 표집 중요도 재표집 Rejection Sampling을 할때 ${k}$를 구하는 과정이 있었는데, 이 과정을 생략해주는 방법이다. ${q(z)}$로부터 ${z^l}$을 추출한다. 각 ${z^l}$에 대한 가중치 ${w_l}$을 계산한다. 각각의 확률이 ${w_l}$을 가지는 이산 분포 ${z^l}$들로부터 다시 ${L}$개를 추출한다. 결국 Rejection Sampling에 Importance Sampling을 덮어준 형태인데, 기본 idea는 같은 것이라 크게 발전된 형태로 보이지는 않는다. 11.1.6 표집법과 EM 알고리즘 EM을 사용할 때, E단계에서 non-analytic한 함수를 만났을 경우 표집법을 통한 근사로 해결이 가능하다. 즉, 적분꼴로 표현된 최적화 대상을 이산 합 형태로 아래와 같이 바꿔주는 것이다. \[Q(\theta, \theta^{old}) = \int p(\textbf{Z} | \textbf{X} , \theta^{old}) \ln p(\textbf{Z},\textbf{X} | \theta) \, d\textbf{Z}\] \[to\] \[Q(\theta, \theta^{old}) \approx \frac{1}{L} \sum \ln p(\textbf{Z}^{(l)}, \textbf{X} \bar \theta )\] 이 과정을 Monte Carlo EM algorithm이라고 부른다. 참고) IP 알고리즘 ${p(\textbf{Z} \mid \textbf{X})}$에서 표집이 어려운 상황에서 Maximum Likelihood 대신 Bayesian하게 접근해서 해결하는 방법. I Step \[p(\textbf{Z} | \textbf{X}) = \int p(\textbf{Z} | \textbf{X} , \theta) p(\theta | \textbf{X}) \, d\theta\] 순서대로 ${\textbf{X}}$로부터 ${\theta ^{(l)}}$들을 추출하고 이들의 결합분포를 통해 ${p(\textbf{Z} \mid \textbf{X} , \theta)}$에서 ${\textbf{X}}$를 추출한다. P Step \[p(\theta | \textbf{X}) = \int p(\theta | \textbf{Z} , \textbf{X}) p(\textbf{Z} | \textbf{X}) \, d\textbf{Z}\] 구한 ${\textbf{Z}}$들을 통해 ${\theta}$에 대한 사후분포식을 수정해준다. 11.2 마르코프 연쇄 몬테 카를로 MCMC는 Rejection Sampling이나 Importance Sampling과 비슷한 방식으로 진행되지만, 무조건 Reject되기 보다는 회생의 기회를 준다는점에서 차이가 있다. 물론 여기서 얻은 표본들도 독립이 아니지만, 충분히 큰 M에 대해 kM번째 샘플만 취해준다면 어느정도 독립성을 보장해줄 수 있다. 먼저, 가장 대표적인 방식인 Metropolis Algorithm에 대해 알아보자. 목표 분포 ${p(z)}$에 대해 Rejection Sampling때와 마찬가지로 적절한 ${q(z)}$를 잡아준다. (Metropolis 알고리즘에서는 대칭(${q(z_A \mid z_B) = q(z_B \mid z_A)}$)임을 가정한다.) 초깃값 ${z^{(1)}}$을 시작으로 ${q(z)}$ 에서 하나의 표본 ${z^*}$을 추출한다. Accept or Reject ${p(z^*) &gt; p(z^{(1)})}$일경우 accept 그렇지 않을 경우, $\frac{p(z^*)}{p(z^{(1)})}$의 확률로 accept한다. 이를 다시표현하면, ${min \left(1, \frac{p(z^*)}{p(z^{(1)})}\right)}$의 확률로 Accept한다. 이에 대한 증명은 적혀있지 않은데, 11.2.2에서 일반화된 증명으로 살펴본다. 11.2.1 마르코프 연쇄 다음 상태가 현재 상태에만 의존할 경우 마르코프하다고 한다. \[{ p(z^{(m+1)} \mid z^{(1)}, \ldots z^{(m)}) = p(z^{(m+1)}\mid z^{(m)} )}\] 각 상태에서 ${T_{m}^{ij} = p(z^{(m+1)} = v_j \mid z^{(m)} = v_i) }$을 Transition Matrix라고 부르며 이 matrix가 ${m}$에 무관할 경우 Homogenous한 chain이라고 부른다. 최종적으로 ergodic 개념이 중요한데, 아래 세 조건은 동치이다. Ergodic Positive Recurrent, Aperiodic Finite, Irreducible, Aperiodic 즉, ergodic하면, 충분한 시간이 흐른 뒤 분포와 초기 분포가 동일한 분포가 된다. 또한, 헷갈리는 개념으로 stationary가 있는데, transition matrix ${T}$에 대해 ${\pi = \pi T}$를 만족할 때, 즉, 분포가 일정할 때 stationary(invariant)하다고 한다. \[p(z^{(m+1)}) = \sum p(z^{(m+1)} \mid z^{(m)}) p(z^{(m)})\] 일반적으로 ergodic하면 stationary한 ${\pi}$가 존재하며 stationary하다. 자세한 내용이 궁금하다면 Stochastic Process를 공부해보자. 재밌는 책이다. 11.2.2 메트로폴리스 헤이스팅스 알고리즘 앞선 Metropolis Algorithm은 대칭 ${q(z)}$만을 사용했는데, 한계가 있으므로 이번에는 좀더 일반적인 상황을 위한 해법을 살펴보자. 유일한 차이는 Accept or Reject할 때이다. 다음과 같이 acceptance rate를 정규화해주면 된다. \[rate_{z, z'} = min\left(1, \frac{\frac{p(z^*)}{q(z^* \mid z^m)}}{\frac{p(z^m)}{q(z^m \mid z^*)}} \right)\] 이제 이렇게 얻은 표본집합이 ${p(z)}$에 수렴한다는 것을 증명해야한다. 책에는 좀 대충나와있는 것 같다. 일단, 각 표본들은 위의 rate를 따르는 MC라고 볼 수 있다. 나아가, acceptance rate를 통해 postivie recurrent함을 확인할 수 있고, 당연하게 Aperiodic하므로, Ergodic한 MC임을 쉽게 볼 수 있다. 따라서, unique한 stationary matrix ${\pi}$를 가짐을 알 수 있다. 이제, ${\pi}$가 ${p(x)}$에 수렴함을 보여야한다. 다음 식을 살펴보자. \[\begin{aligned}p(z)q(z'\mid z) * rate_{z, z'} &amp;= min\left(p(z)q(z'\mid z), p(z')q(z\mid z')\right) \\ &amp;= min\left(p(z')q(z\mid z'), p(z)q(z'\mid z)\right) \\ &amp;= p(z')q(z\mid z') * rate_{z', z}\end{aligned}\] 따라서, ${q(z)}$와 rate의 결합은 이 MC의 transition probability라고 볼 수 있으며, 결국 같은 ${\pi}$에 수렴함을 알 수 있다. 마찬가지로, 어떤 ${q(z)}$를 사용하는지에 따라 알고리즘의 성능에 현저한 영향을 줄 수 있다. 일반적으로 gaussian을 사용한다. 여기서 분산을 어떻게 두냐에 따른 trade-off가 있는데, 분산이 작을 경우 acceptance는 증가하지만, 전체를 탐색하기 오래걸리고, 분산이 클 경우 acceptance 자체가 낮아지게 된다. 따라서 그림 11.10과 같이 방향에 따라 분산의 차이가 클 경우 알고리즘이 느리게 수렴하게 된다. 11.3 깁스 표집법 알고보니 Gibbs Free Energy를 정의한 그 Gibbs이다. 이쪽업계 코시 같은 사람인듯; 아무튼 Gibbs Sampling은 MCMC의 한 종류이다. 방법은 간단한데, ${m}$개의 확률변수들이 결합된 결합확률분포가 있을 때, ${m - 1}$개의 변수를 고정시키고 남은 한개를 조건부 확률분포로 부터 표집하고, 다른 ${m-1}$개를 고정시키고 남은 한개를 표집하고 … 을 반복해서 얻어나가는 방법이다. 너무 rough하게 적은것 같으니 좀더 정확하게 설명하면 ${T}$회 반복하는 경우 아래와 같다. initialize ${z_i : i = 1, \ldots M}$ for ${i}$ in range (${1}$, ${T}$) ${p(z_1 \mid z_2^{i},z_3^{i},\ldots,z_M^{i})}$에서 ${z_1^{i+1}}$을 표집한다. ${p(z_2 \mid z_1^{i+1},z_3^{i},\ldots,z_M^{i})}$에서 ${z_2^{i+1}}$을 표집한다. ${\vdots}$ ${p(z_M \mid z_1^{i+1},z_2^{i+1},\ldots,z_{M-1}^{i+1})}$에서 ${z_M^{i+1}}$을 표집한다. 여기서는 변수들에게 order를 부여하고 진행했는데, random한 order로 진행할 수도 있다. 물론 결과적으로는 같다. 이제, 이 기법이 올바른 샘플링임을 증명해보자. MH 알고리즘의 일종이라고 언급했으니 이게 왜 MH 알고리즘인지 증명해보면 된다. 좀 rough하게 살펴보자. 일단, 이 분포 또한 MH에서 사용한 분포와 같이 stationary함을 보여야한다. 이는 꽤나 자명한데, 각 표집에서 적절한 조건부 분포를 사용하기 때문이다. 즉, 적할한 ${\pi}$가 존재한다. \[\begin{aligned} rate &amp;= min\left( 1, \frac{p(z^*)q(z|z^*)}{p(z)q(z^*|z) } \right)\\ &amp;= min\left(1, \frac{p(z^*_k|z^*_{-k})p(z^*_{-k})p(z_k | z^*_{-k})}{p(z_k|z_{-k})p(z_{-k})p(z^*_{k}|z_{-k})} \right) \\ &amp;= min(1,1) = 1\end{aligned}\] 즉, MH와 같은 rate를 가지고 있기 때문에, MH의 일종으로 볼 수 있다. 11.4 조각 표집법 계속해서 보이는 알고리즘들의 단점은 ${p(z)}$와 ${q(z)}$의 차이에서 비롯되었다. 분산이 작으면 탐색이 느리고, 크면 acceptance가 낮아진다. 조각표집법(slice sampling)은 새로운 방식으로 해결하고자 했다. 아이디어는 간단한데, 아래와 같이 y축에서 쳐다보는 변수 ${u}$를 추가해서 해결하는 것이다. \[\hat p(z,u) = \begin{cases} 1/Z_p &amp; 0 \leq u \leq \hat p(z) \\ 0 &amp; else \end{cases}\] 그리고, 깁스 샘플링 같은 방법을 통해 ${\hat p(z,u)}$에서 표본을 얻고, ${u}$를 무시해주어 원 분포를 얻는 방식이다. 근데 이건 그냥 원래 있던 inverse cdf하는 방법보다도 원시적인 방법이 아닌가 싶다. 11.5 하이브리드 몬테 카를로 알고리즘 11.6 분할 함수 추정]]></summary></entry><entry><title type="html">유산소 인터벌 도입</title><link href="http://localhost:4000/%EC%9A%B4%EB%8F%99/interval/" rel="alternate" type="text/html" title="유산소 인터벌 도입" /><published>2022-07-14T00:00:00+09:00</published><updated>2022-07-14T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EB%8F%99/interval</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EB%8F%99/interval/"><![CDATA[<p>개인 유산소 운동은 페이스 유지하면서 달리는 일반적인 조깅만 해왔었는데, 최근에 인터벌을 도입하고 오늘 2번째로 뛰어보았다.</p>

<p>효과가 있는지는 풋살할 때 확인할 수 있겠지만, 일단 너무 힘듬.. 원래 인터벌하시는 분들 보면 전속력-천천히를 한세트로 10번 정도 조지시던데 나는 5세트정도에 뻗어버림; 전속력이 진짜 전속력이 아닌건지 천천히를 진짜 완전 천천히로 해야하는지 뭔가 잘못된거 같기도 한데, 좀더 알아봐야겠다.</p>

<p>지금은 이렇게 달리고 있다.</p>
<ul>
  <li>전속력 : 3분 초반 페이스로 30초</li>
  <li>천천히 : 6분 초반 페이스로 90초</li>
</ul>

<p>일단 지금까지 느낀 조깅과 인터벌 차이.</p>

<p>조깅</p>
<ul>
  <li>낮은 젖산농도 구간에서 오랜시간 지방을 태울 수 있어 체지방 태우는데 더 좋은 느낌</li>
  <li>생각 정리에 도움이 되고 몸이 맑아지는 기분</li>
</ul>

<p>인터벌</p>
<ul>
  <li>젖산농도 끝에서 조져서 지방이고 뭐고 그냥 대둔근 타겟으로 조져지는 느낌</li>
  <li>생각을 할 수가 없고 뇌의 미세혈관이 막혀버리는 기분</li>
  <li>가끔 자전거를 추월할 때 기분이 좋다. 물론 곧 따라잡히지만.</li>
</ul>]]></content><author><name>Jaehyun Kim</name></author><category term="운동" /><category term="유산소" /><summary type="html"><![CDATA[개인 유산소 운동은 페이스 유지하면서 달리는 일반적인 조깅만 해왔었는데, 최근에 인터벌을 도입하고 오늘 2번째로 뛰어보았다. 효과가 있는지는 풋살할 때 확인할 수 있겠지만, 일단 너무 힘듬.. 원래 인터벌하시는 분들 보면 전속력-천천히를 한세트로 10번 정도 조지시던데 나는 5세트정도에 뻗어버림; 전속력이 진짜 전속력이 아닌건지 천천히를 진짜 완전 천천히로 해야하는지 뭔가 잘못된거 같기도 한데, 좀더 알아봐야겠다. 지금은 이렇게 달리고 있다. 전속력 : 3분 초반 페이스로 30초 천천히 : 6분 초반 페이스로 90초 일단 지금까지 느낀 조깅과 인터벌 차이. 조깅 낮은 젖산농도 구간에서 오랜시간 지방을 태울 수 있어 체지방 태우는데 더 좋은 느낌 생각 정리에 도움이 되고 몸이 맑아지는 기분 인터벌 젖산농도 끝에서 조져서 지방이고 뭐고 그냥 대둔근 타겟으로 조져지는 느낌 생각을 할 수가 없고 뇌의 미세혈관이 막혀버리는 기분 가끔 자전거를 추월할 때 기분이 좋다. 물론 곧 따라잡히지만.]]></summary></entry><entry><title type="html">인간실격</title><link href="http://localhost:4000/book/Book-no-longer-human/" rel="alternate" type="text/html" title="인간실격" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>http://localhost:4000/book/%5BBook%5D-no-longer-human</id><content type="html" xml:base="http://localhost:4000/book/Book-no-longer-human/"><![CDATA[<h2 id="후기">후기</h2>

<p>전개가 어지러워서 정신을 차리고 읽느라 애를 먹었다. 호밀밭의 파수꾼을 다른 버전으로 읽는 느낌을 받았고 일본 소설만의 표현하기 어려운 그 특유의 분위기가 조금은 불쾌하기도 했다.</p>

<p>주인공 요조는 그야말로 염세주의에 제대로 빠진 사람으로 보였는데, 낙관주의에 가까운 나로서는 그의 가정환경과 일련의 행동들이 그저 안타깝게 보일 뿐이었다.</p>

<p>요조의 허무주의는 분명 패전으로 무너진 일본인들을 대변해주는 좋은 인물이었을 것 같다. 더구나 자살을 보는 사회적인 시각이 지금과 같지 않고 본인의 존엄성을 지키기 위한 마지막 자주적 선택 정도였던 일본 문화를 비추어 보았을 때 당시 이 책이 일본인들 사이에서 선풍적인 인기를 끌었음은 짐작이 간다.</p>

<p>그런데 아직까지도 사랑받는 이유는 사실 잘 모르겠다. 한국에 요조에 공감할 정도로 염세주의와 허무주의에 빠진 사람들이 이렇게 많은가? 당시 일본의 상황에 이입해서 읽고 있는 것인가? 잘은 이해되지 않는다만 2030에서 판매량이 많았던 것을 통해 최대한 유추해보면 전자에 가깝지 않을까 싶다.</p>

<p>조금 더 날 것의 표현을 하자면 그가 잘생긴 얼굴을 바탕으로 주변 헬스인의 권유로 운동에 취미를 붙였다면 이 정도로 염세주의에 과몰입하지는 않았을 것으로 생각한다.</p>

<h4 id="추천하는-독자">추천하는 독자</h4>

<p>파괴된 삶의 날선 묘사가 궁금한 사람</p>

<h4 id="추천하지-않는-독자">추천하지 않는 독자</h4>

<p>허무주의 부류에 빠진 사람</p>

<p>비도덕적인 요소들에 불쾌감을 느끼는 독자</p>

<h4 id="한-문장">한 문장</h4>

<blockquote>
  <p>부끄럼 많은 생애를 보내왔습니다. 저는 인간의 삶이라는 것을 도무지 이해할 수 없습니다.</p>
</blockquote>

<p>그래 .. 알고있다 …</p>]]></content><author><name>Jaehyun Kim</name></author><category term="book" /><category term="novel" /><summary type="html"><![CDATA[후기]]></summary></entry><entry><title type="html">2022 상반기 회고</title><link href="http://localhost:4000/misc/2022-fisthalf-rem/" rel="alternate" type="text/html" title="2022 상반기 회고" /><published>2022-07-07T00:00:00+09:00</published><updated>2022-07-07T00:00:00+09:00</updated><id>http://localhost:4000/misc/2022-fisthalf-rem</id><content type="html" xml:base="http://localhost:4000/misc/2022-fisthalf-rem/"><![CDATA[<h2 id="상반기-목표">상반기 목표</h2>

<p>대략 3월쯤 세운 상반기 <strong>기존 목표</strong>는 아래와 같다.</p>

<ul>
  <li>ML 스터디 성실히 진행</li>
  <li>학점 4 이상</li>
  <li>코포 시작, 퍼플 레이팅 만들기 (올해 내로)</li>
  <li>건강 관리 4점 이상</li>
  <li>돈 관리</li>
</ul>

<h2 id="상반기-결산">상반기 결산</h2>

<p>결과적으로 6월까지 해온 것들은 다음과 같다.</p>

<ul>
  <li>ML 스터디 진행중
    <ul>
      <li><a href="http://www.yes24.com/Product/Goods/88440860">단단한 머신러닝</a> 완주</li>
      <li><a href="https://puffy-stick-fa1.notion.site/2022-ca5f43fc259d446d81f376256d18b99b">우아한 스터디</a>에서 <a href="http://www.yes24.com/Product/Goods/64189352">PRML</a> 진행중</li>
    </ul>
  </li>
  <li>학점 4.1</li>
  <li>코포 블루 달성 (초반에 달성 후 중단 중)</li>
  <li>건강 관리 3점
    <ul>
      <li>초반 4점(식단, 헬스) -&gt; 후반 2점(간헐적 러닝)</li>
      <li>영양제는 잘 챙겨먹음(종비, 칼맥, 유산균, 오메가3)</li>
    </ul>
  </li>
  <li>
    <p>과외 2개, 튜터링 1개로 유지</p>
  </li>
  <li>네이버 파이낸셜 BE직군 합격</li>
  <li>스타트업 BE 포지션 제안</li>
  <li><del>롤 골드, 롤체 다이아(초반에 달성)</del></li>
</ul>

<h2 id="요약">요약</h2>

<p>학기 초에는 알고리즘만 주구장창 공부하면서 좀 놀았고,</p>

<p>학기 중에는 ML 공부에 집중하고,</p>

<p>학기 말에는 기말고사와 회사 면접으로 정신없이 보냈다.</p>

<h2 id="회고">회고</h2>

<p>총점을 주자면 4점 정도 주고 싶다.</p>

<p>학기와 병행하면서 CS지식 처음부터 쌓아서 네이버에 최종 합격한 점에서 높은 점수를 주고 싶고, 아쉬운 점이라면 생활패턴을 지키지 못해서 건강 관리를 놓친 거? 아직은 그래도 젊어서 별 문제는 없었다만 더 나이들기 전에 확립해야한다는 생각을 종종한다,,</p>

<p>그리고 독립 생활 유지 또한 잘 해오고 있고 이것저것 찾아서 지원금 받고 스터디하고 야무지게 살고 있는듯.</p>

<h2 id="2022-하반기-계획">2022 하반기 계획</h2>

<p>일단 교수님과 면담을 통해 석사 휴학을 하기로 했고, 당분간 회사를 다닐 것 같다. 어떤 회사에서 어떤 직군으로 다닐지 한 달 동안 고민을 했는데, 석사 졸업하면 평생 BE 직군으로 일할 기회는 굳이 없을 것 같기도 하고 마침 직무도 흥미가 끌리는 쪽이라서 돈도 모을겸 네이버 다니는게 좋은 판단일 것 같다.</p>

<p>뭐 또 바뀌겠지만 지금 목표도 세워보았다.</p>

<ul>
  <li><strong>JAVA, Spring 공부</strong>
    <ul>
      <li>사실 java/spring 경험자가 지원자격이였는데 전혀 모르는 내가 어떻게 붙은지 모르겠다;; 심지어 자기소개서 서류도 잘못냈는데 ,,</li>
      <li>어쨌든 다니기로 했으니 빠르게 입사 전까지 공부해가야 할듯.</li>
      <li>물론 회사 가서도 계속 배워야지 ,,</li>
      <li>+) 클린코드 읽기</li>
    </ul>
  </li>
  <li>코포 퍼플 달성
    <ul>
      <li>왠지 조금 시간 투자하면 금방 갈 것 같은 느낌</li>
    </ul>
  </li>
  <li>ML 스터디 지속</li>
  <li>건강 관리
    <ul>
      <li>일단 이번엔 집앞 헬스장 등록하고.. 집 앞에 테니스장이 있길래 테니스를 배워볼까 생각 중이다. 물론 러닝은 꾸준히</li>
      <li>피부과 매달 방문</li>
    </ul>
  </li>
  <li>돈 관리
    <ul>
      <li>이제 월급을 받으니 ,, 좀더 구체적으로 ,,</li>
    </ul>
  </li>
</ul>]]></content><author><name>Jaehyun Kim</name></author><category term="misc" /><category term="etc" /><summary type="html"><![CDATA[상반기 목표]]></summary></entry><entry><title type="html">Github 블로그 개장</title><link href="http://localhost:4000/misc/hello-blog/" rel="alternate" type="text/html" title="Github 블로그 개장" /><published>2022-07-05T00:00:00+09:00</published><updated>2022-07-05T00:00:00+09:00</updated><id>http://localhost:4000/misc/hello-blog</id><content type="html" xml:base="http://localhost:4000/misc/hello-blog/"><![CDATA[<h2 id="드디어-개장">드디어 개장!</h2>

<p>중학교 ~ 대학교 1학년 때까지 네이버 블로그를 사용하다 네이버의 정책이 맘에 안들어 티스토리로 도망쳤다가, 결국 그놈이 그놈이라 근본 github으로 넘어왔다!</p>

<h2 id="과정">과정</h2>

<p>우선 <strong>TOC</strong>가 꼭 있는 테마를 추려내고, 디자인이 맘에 드는 것들을 골랐는데,
처음에는 <a href="https://jeffreytse.github.io/jekyll-theme-yat/">yat</a>과 <a href="https://just-the-docs.github.io/just-the-docs/">just-the-docs</a> 테마가 선정되었다!</p>

<p>근데 docs가 좀 부실하고 자잘한 이슈들이 있어, 결국 docs 잘돼어 있고 많이들 쓰는 <a href="https://github.com/mmistakes/minimal-mistakes">minimal-mistakes</a>로 정착하게 되었다. 역시 많이 쓰는덴 이유가 있어…</p>

<h2 id="1일-후기">1일 후기</h2>

<p>일단 css를 직접 만질 수 있어서 너무 편하다~~</p>

<p>말그대로 jekyll을 사용한다는 것만 빼면 첨부터 빌드하는건데 역시 내 손으로 직접 쌓아야 마음이 편한듯 ,,</p>

<p>그리고 무엇보다 post도 markdown으로 슥슥 써내릴 수 있어서 부담감이 덜하다 !</p>

<p>학부 때 맨날 하던게 latex로 과제 짜고 typora로 필기하는거였는데 이게 블로그에서도 가능하다니 !
(더 이상 마우스로 손이 가지 않아도 되는거야)</p>

<h2 id="운영-방향">운영 방향</h2>

<p>네이버 블로그할 때는 누군가에게 설명하기 위한 글을 썼었는데, 아무래도 그런식의 블로깅은 부담감이 있어 잘 안쓰게 된다,,</p>

<p>따라서, 이번 블로그는 애초에 검색 노출부터 따로 설정하지 않고 공부한/했던 내용들을 아카이빙하는 방향으로 했다 !</p>

<p>짧은 가방끈이지만 나름 다양한 공학 영역의 공부를 했기에,, 적을 수 있는 내용이 많을 것 같다 !</p>]]></content><author><name>Jaehyun Kim</name></author><category term="misc" /><category term="etc" /><summary type="html"><![CDATA[드디어 개장!]]></summary></entry></feed>